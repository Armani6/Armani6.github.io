{"meta":{"title":"喵绪~~","subtitle":"欢迎访问本网站，这是我的个人博客！","description":null,"author":"Armani","url":"https://z.zhsh666.xyz","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"08-24","excerpt":""},{"title":"分类集合","text":"","path":"categories/index.html","date":"08-25","excerpt":""},{"title":"留言板","text":"有什么问题或想说的可以在这里讲哦~","path":"message/index.html","date":"08-24","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"08-24","excerpt":""},{"title":"标签集合","text":"","path":"tags/index.html","date":"08-25","excerpt":""},{"title":"关于&留言板","text":"个人简介张 帅， 就读于安徽电子信息职业技术学院，目前处于上升阶段，不断努力！。 喜欢研究新兴技术和未来发展方向。 最近学习在学习Java基础知识，Swing、Javaweb、JavaScript、PHP等技术。 关于名字Zevs 宙斯是一个男孩的名字是希腊裔，宙斯的意思是“活的”。奥林匹亚神的酋长的名字，以及诸如雅典娜，阿瑞斯，阿波罗和阿提弥斯等神和女神的父亲。希腊神的名字，与古老的印欧神* Dyeus有关，其名字可能意味着“闪耀”或“天空”。在希腊神话中，他是最高的神。在他和他的兄弟姐妹击败了泰坦之后，宙斯统治着奥林匹斯山上的地球和人类。他控制了天气，他的武器是一个雷电。寓意着越来越强大 喜欢音乐 联系方式 QQ :2602138376 邮箱 : 2602138376@qq.com","path":"about/index.html","date":"08-14","excerpt":""}],"posts":[{"title":"遥想当年","text":"缘起起这个题目，是我向过去的我表示道别，向未来的我挥手示意。 不经意间看到了电脑右下角的日期-2019/8/26,恍惚之间，曾经憧憬并向往的大学的生活也过去了所谓的三分之一还要多了。起初填报志愿的时候，十所院校每个院校六个志愿填的均是与计算机有关，我想这大抵就是喜欢吧。 开学之前憧憬着在学校可以学到很多厉害的技术以及找到自己的兴趣与目标。结果，一年过去了，或许是对自己有失望吧。在学习上，是那种浑浑噩噩的状态，然后依靠着考试周前段时间分析勉勉强强拿了一个一般般的绩点。在专业上，学了C和html，有时候都没有了计算机专业的那种依附感，感觉跟其他专业的学生没啥两样，学的大致一样的公共课，总之专业性不是很强吧。至于专业课考试这一说，哪怕一点不学，最后依靠老师给的题都可能考个高分。自己也并没有把重点放到专业课上面去，有时候听不懂就那样含糊过去了，因为知道哪怕不听一点点不会，最后考试还是能过的。就这样恍惚间过去了一年，专业就跟没学差不多，脑海中也就残留着点点C的基础知识。就连计算机二级也没过。这些是学习上的，可谓是不尽人意。生活上，也还算充实，参加了各种社团和学生会的干事，就这样很少去过过一个完整的双休了，不是开会就是开会，有时候忙到凌晨几点还在那里写着策划书出海报等。总有着交不完的文件，写不完的策划书，开不完的会，熟悉的就那一地滴咚@全体成员。基本大部分的课余时间都被这些占用了。有时也会抱怨上几句，当然自己并不后悔去做这些，虽然看起来忙忙碌碌不知道在忙些什么，但是在我眼里这更是一种责任，既然选择了，就应勇于担当。比如，总队元旦晚会的节目准备，足足玩了一个多月时间，每次都是下完晚自习就过去跟几个小伙伴一起找好地方排练舞蹈节目，每天排练到十点多回去，虽然看起来会占用不少时间还要花费不少精力，但是我排练的很开心，乐在其中，每晚一到点就去那，以至后来晚会结束了，晚上不用排练了，心里还有点空落落的感觉。 一年里，接触了很多人，在这其中交了不少玩的开心的朋友及几个交心的兄弟。要知道人越长大，友谊就愈发显得珍贵。 说到这, 在此要感谢那些这一年一路给予我支持和关心的小伙伴们，谢谢你们 ! 终于，不知从什么时候起醒悟了许多。我想在未来的日子里，我应该做点什么了，逝者如斯夫，应该把生活过的像自己想要的那样，才对嘛。 之前初中的时候喜欢鼓捣网站，刚进入大学就买了个zhsh666.xyz（原本想用自己的名字首字母，可惜已经被人注册了，只好加个6在加个6再加个6才可以）的域名，起初以为有了域名就能发布自己的东西，后来因为技术不够等等原因不了了之了。如今暑假在家闲暇之余又重新接触了到了hexo这一块，用专业术语来说，名曰前端。发现自己对着前端有着浓厚的兴趣，便打算开始入手学习前端技术，即使很多人说前端的发展没有后端好，什么前端门槛低，工作了用的也少还不如花着时间去弄弄算法等等这些吐槽前端的话语，以及发展前景不好，我觉得不应该把自己限制在“前端”上，前端工程师本质是工程师，这点来说跟后端工程师是一致，只是前端工程师负责了前端这块，而不是跟后端工程师决裂的。前后端分离只是团队合作的一种生产方式，而不是个人学习上的割裂。如果只关注自己的页面领域，发展的空间当然会有所限制。 更重要的是一定要去做自己所热爱的事现在我知道了，人的根本区别不在于家庭身份，不在于长相外貌，不在于学历学位，只在于自身。在这个世界上，只有自己能掌握自己的命运。没有任何人可以阻止我们前进，只要我们自己往前走。没有任何人能把我们从泥泞中拉起来，只有我们自己可以爬起来。这个世界上90%的人都是追随者但你要对自己说:“我不是，我是来引领这个世界的!” 有时，挡住我们前进的脚步的，恰恰是不愿意迈出第一个脚步的我们自己。 就像知乎说的那样，与世界分享你的知识和见解。好了，那这第一篇文章就作为我新阶段的开始，通过博客的方式来记录学习过程的中的一些感悟，与大家分享一些技术知识及经验。 最后送大家一句共勉; 相信每天的自己与前日相比都是一个崭新的自己，明天的自己能学到更多的东西","path":"2019/08/26/遥想当年/","date":"08-26","excerpt":"","tags":[]},{"title":"物语系列","text":"视频简介： 作品以21世纪初的日本直江津镇为舞台，描述一名高中少年阿良良木历与少女们遇到许多日本民间传说的怪谭故事。 本作品跟一般怪谭故事不同，不以击退妖怪或寻找事发原因之类的解谜作为主线。 作品主要透过对话，为男主角和少女们之间的内心作深刻描写。 西尾维新以其特有的“话痨”风格，将大量的对话和心理描写穿插到主线事件中，同时还加入了许多后设以及对社会和其他作品的讽刺。 故事之中既有恋爱喜剧，又有热血的动作描写，可见作者把想要的东西都写进作品中去。 所以，作者将“物语系列”自评本作为他的自信作，亦称之为“以很难媒体化为目的而写的小说”。 观看顺序： 《化物语》-《伪物语》-《猫物语(黑)》-《猫物语(白)》-《倾物语》-《囮物语》-《鬼物语》-《恋物语》-《花物语》-《凭物语》-《终物语》-《历物语》-《伤物语》 百度网盘： https://d.oo14.com/26BK 电脑壁纸：","path":"2019/08/26/物语系列/","date":"08-26","excerpt":"","tags":[{"name":"物语","slug":"物语","permalink":"https://z.zhsh666.xyz/tags/物语/"}]},{"title":"一款超级强大的系统优化工具","text":"CCleaner是一款电脑系统优化清理软件，体积小巧，文件大小只有不到5MB，扫描速度快，它主要有2大功能：清除Windows系统垃圾文件；清除上网记录。 1.清理临时文件夹、历史记录、回收站等垃圾信息; 2.扫描清理注册表垃圾键值; 3.ccleaner中文版内置软件卸载模块，可以选择卸载软件或者选择仅删除卸载条目; 4.支持清除 IE、Firefox 、Oprea 等浏览器的历史记录、Cookies、自动表单记录等隐私信息; 5.可以选择清理常用软件的历史使用记录!如：Media Player, winrar, Netscape, MS Office, Adobe Acrobat, 画笔, 记事本等，免费使用，不含任何间谍软件和垃圾程序。 使用建议：1.CCleaner 默认会清理所有浏览器的 Cookies，建议清理时取消勾选避免网站需要重复登录； 2.CCleaner 默认会开机自启动并常驻后台来扫描缓存文件，如无必要建议关闭之； 3.缓存文件可以帮助你更快的打开某个网页或者是软件等，因此定期清理缓存文件即可； 4.不建议清理系统还原点和回收站内容防止内容丢失，你可以手动清理更放心； 5.对于经常安装和卸载软件的用户建议清理注册表，但清理前注意点个备份注册表； 软件下载：点击下载","path":"2019/08/26/一款超级强大的系统优化工具/","date":"08-26","excerpt":"","tags":[]},{"title":"找到惹一个好看的h5引导页","text":"看见群里一个沙雕网友在弄引导页那是真的不好看emm反正我不喜欢就是了我就想着给他找找。 一开始发现了identity这个,这个也是很好看的就是不够花里胡哨，然后又翻了翻这个网站就找到了这篇文章的猪脚DIMENSION对就是这个。很符合一个中二病的审美。 电脑截图 手机截图 下载https://html5up.net/dimension/download 使用注意加载过慢就去把main.css里的谷歌字体替换成国内CDN好了就这样吧 如果有什么不懂的话可以留言 我会尽我所能解答的","path":"2019/08/26/找到惹一个好看的h5引导页/","date":"08-26","excerpt":"","tags":[{"name":"引导页","slug":"引导页","permalink":"https://z.zhsh666.xyz/tags/引导页/"}]},{"title":"SpringBoot入门系列：第二篇 再学Hello World","text":"Spring-Boot是Spring的新东东，为了让人尽快的使用，它提供了一个非常好的辅助工具，直接为我们生成Maven架构的工程。下面，我们通过helloworld看 一、在浏览器中打开http://start.spring.io/，如图 在Artifact中输入spring-boot-sample-helloworld，点击“Switch to the full version.”，勾选”web”，然后点击“ Generate Project alt +”按钮，把文件保存到本地某个位置 二、下载文件导入eclips 1、解压下载的文件到某个文件夹； 2、在eclips中导入工程file-&gt;import-&gt;Import Existing Maven Projects–&gt;Select Maven projects–&gt;finish 3、在eclips中运行工程，正确则入图 三、添加HelloController 1、在包com.example中点击右键，选择new-&gt;class,再在Name中输入HelloController,入下图 在上图中点击”Finish” 2、在类上面条件声明@RestController 3、增加方法 123456789@RequestMapping(&quot;/&quot;) public String helloworld()&#123; return &quot;Hello world!&quot;; &#125; @RequestMapping(&quot;/hello/&#123;name&#125;&quot;) public String hellName(@PathVariable String Name)&#123; return &quot;Hello &quot;+Name; &#125; 4、保存Ctrl+S5、自动添加引用 Ctrl+SHift+O 6、整个HelloController文件如下 12345678910111213141516171819package com.example; import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; @RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/&quot;) public String helloworld()&#123; return &quot;Hello world!&quot;; &#125; @RequestMapping(&quot;/hello/&#123;name&#125;&quot;) public String hellName(@PathVariable String name)&#123; return &quot;Hello &quot;+name; &#125;&#125; 7、启动测试在浏览器中依次输入 http://localhost:8080/ http://localhost:8080/hello/上帝","path":"2019/08/25/SpringBoot鍏ラ棬绯诲垪锛氱浜岀瘒 鍐嶅Hello World/","date":"08-25","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"https://z.zhsh666.xyz/tags/java/"},{"name":"Java","slug":"Java","permalink":"https://z.zhsh666.xyz/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://z.zhsh666.xyz/tags/SpringBoot/"}]},{"title":"SpringBoot入门系列：第三篇 日志输出","text":"Java程序，日志输出，我认为是第一位的，把它的应用拿到这里。 Spring-Boot对日志的处理，和我们往常的处理完全可以一致，通过logback.xml进行处理，即使有更先进的东西，我们也不用去管它。 这里，为了简便，我们任然使用前一篇的工程spring-boot-sample-data 第一步，在src/main/resources中增加logback.xml文件，文件内容为（这里仅最简单的，根据工程情况，进行相应的配置）： 1234567891011121314151617181920212223242526272829303132&lt;pre name=&quot;code&quot; class=&quot;html&quot;&gt;&lt;configuration&gt; &lt;!-- %m输出的信息,%p日志级别,%t线程名,%d日期,%c类的全名,,,, --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d %p (%file:%line\\)- %m%n&lt;/pattern&gt; &lt;charset&gt;GBK&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;baselog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;File&gt;log/base.log&lt;/File&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;log/base.log.%d.%i&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;!-- or whenever the file size reaches 64 MB --&gt; &lt;maxFileSize&gt;64 MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt; %d %p (%file:%line\\)- %m%n &lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt; &lt;logger name=&quot;com.example&quot; level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;baselog&quot; /&gt; &lt;/logger&gt; &lt;/configuration&gt; 注：1、控制台和日志文件的字符集 ​ 2、日志文件的存放位置，须要遵守linux的命名规则 第二步，改造HelloController文件，改造结果如下 12345678910111213141516171819202122232425package com.example; import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; @RestControllerpublic class HelloController &#123; protected static Logger logger=LoggerFactory.getLogger(HelloController.class); @RequestMapping(&quot;/&quot;) public String helloworld()&#123; logger.debug(&quot;访问hello&quot;); return &quot;Hello world!&quot;; &#125; @RequestMapping(&quot;/hello/&#123;name&#125;&quot;) public String helloName(@PathVariable String name)&#123; logger.debug(&quot;访问helloName,Name=&#123;&#125;&quot;,name); return &quot;Hello &quot;+name; &#125;&#125; 注：在添加引用时，日志的包一定是org.slf4j.Logger、org.slf4j.LoggerFactory 第三步、测试 1、运行程序 2、在浏览器中依次输入 http://localhost:8080/ http://localhost:8080/hello/上帝 3、在工程所在的根目录找到log文件夹，进去，再打开base.log，入下图 注：文件夹和日志文件的名称，都是在配置文件logback.xml中设置的 通过这个实例，我们完全用过去的技术处理日志，暂时不用去管别的，直接使曾经的技术。 注，日志分级输出配置文件格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 属性描述: scan:设置为true时，配置文件如果发生变化，将会被重新加载，默认为true. scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟. debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false --&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;30 seconds&quot; debug=&quot;false&quot;&gt; &lt;!-- 定义日志文件的存放位置 --&gt; &lt;property name=&quot;log_dir&quot; value=&quot;target/logs&quot;/&gt; &lt;!-- 日志存放最大天数 --&gt; &lt;property name=&quot;maxHistory&quot; value=&quot;30&quot;/&gt; &lt;!-- 日志编码格式 --&gt; &lt;property name=&quot;encoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;!-- 日志输出格式：简化格式 --&gt; &lt;property name=&quot;plain&quot; value=&quot;%msg%n&quot;/&gt; &lt;!-- 日志输出格式：常用控制台输出格式 --&gt; &lt;property name=&quot;std&quot; value=&quot;%d&#123;HH:mm:ss.SSS&#125;[%thread][%-5level]%logger -%msg%n&quot;/&gt; &lt;!-- 日志输出格式：通常格式 --&gt; &lt;property name=&quot;normal&quot; value=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] [%-5level] %msg%n&quot;/&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;plain&#125;&lt;/pattern&gt; &lt;charset&gt;$&#123;encoding&#125;&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- ERROR级别日志 --&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其它文件 --&gt; &lt;appender name=&quot;ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 过滤器，只记录ERROR级别日志 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 最常用的滚动策略，它根据时间来制定滚动策略。既负责广东也负责出发滚动 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 日志输出位置 可相对，也可以绝对路径 --&gt; &lt;fileNamePattern&gt;$&#123;log_dir&#125;/%d&#123;yyyy-MM-dd&#125;/error-log.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。 假设每个月滚动，且&lt;maxHistory&gt;是6,则只保留最近6个月的文件，删除之前的旧文件。 注意，删除旧文件时，那些为了归档而创建的目录也会被删除 --&gt; &lt;maxHistory&gt;$&#123;maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 按照固定窗口模式生成日志文件，当文件大于20MB时，生成新的日志文件。窗口大小是1到3，当保存了3个归档文件后，将覆盖最早的日志。 &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log_dir&#125;/%d&#123;yyyy-MM-dd&#125;/.log.zip&lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;3&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; --&gt; &lt;!-- 查看当前活动文件的大小，如果超过指定大小会告知RollingFileAppender 触发当前活动文件滚动 &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt; &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; --&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;normal&#125;&lt;/pattern&gt; &lt;charset&gt;$&#123;encoding&#125;&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- WARN级别日志 appender --&gt; &lt;appender name=&quot;WARN&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 过滤器，只记录WARN级别的日志 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;WARN&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 按天回滚 daily --&gt; &lt;fileNamePattern&gt;$&#123;log_dir&#125;/%d&#123;yyyy-MM-dd&#125;/warn-log.log &lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 60天 --&gt; &lt;maxHistory&gt;$&#123;maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger - %msg%n&lt;/pattern&gt; &lt;charset&gt;$&#123;encoding&#125;&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- INFO级别日志 appender --&gt; &lt;appender name=&quot;INFO&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 过滤器，只记录INFO级别的日志 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 按天回滚 daily --&gt; &lt;fileNamePattern&gt;$&#123;log_dir&#125;/%d&#123;yyyy-MM-dd&#125;/info-log.log &lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 60天 --&gt; &lt;maxHistory&gt;$&#123;maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- DEBUG级别日志 appender --&gt; &lt;appender name=&quot;DEBUG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 过滤器，只记录DEBUG级别的日志 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 按天回滚 daily --&gt; &lt;fileNamePattern&gt;$&#123;log_dir&#125;/%d&#123;yyyy-MM-dd&#125;/debug-log.log &lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 60天 --&gt; &lt;maxHistory&gt;$&#123;maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- TRACE级别日志 appender --&gt; &lt;appender name=&quot;TRACE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 过滤器，只记录ERROR级别的日志 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;TRACE&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 按天回滚 daily --&gt; &lt;fileNamePattern&gt;$&#123;log_dir&#125;/%d&#123;yyyy-MM-dd&#125;/trace-log.log &lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 60天 --&gt; &lt;maxHistory&gt;$&#123;maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name=&quot;root&quot;&gt; &lt;level value=&quot;ERROR&quot;/&gt; &lt;/logger&gt; &lt;logger name=&quot;com.demo&quot;&gt; &lt;level value=&quot;DEBUG&quot;/&gt; &lt;/logger&gt; &lt;!-- root级别 DEBUG --&gt; &lt;root level=&quot;debug&quot;&gt; &lt;!-- 控制台输出 --&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;!-- 文件输出 --&gt; &lt;appender-ref ref=&quot;ERROR&quot; /&gt; &lt;appender-ref ref=&quot;INFO&quot; /&gt; &lt;appender-ref ref=&quot;WARN&quot; /&gt; &lt;appender-ref ref=&quot;DEBUG&quot; /&gt; &lt;appender-ref ref=&quot;TRACE&quot; /&gt; &lt;/root&gt; &lt;/configuration&gt; ​","path":"2019/08/25/SpringBoot鍏ラ棬绯诲垪锛氱涓夌瘒 鏃ュ織杈撳嚭/","date":"08-25","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"https://z.zhsh666.xyz/tags/java/"},{"name":"Java","slug":"Java","permalink":"https://z.zhsh666.xyz/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://z.zhsh666.xyz/tags/SpringBoot/"}]},{"title":"SpringBoot入门系列：第四篇 日志详解","text":"一、日志框架的介绍 市面上有许多的日志框架，比如 JUL（ java.util.logging）， JCL（ Apache Commons Logging）， Log4j， Log4j2， Logback、 SLF4j、 jboss-logging等等。 Spring Boot 2.*默认采用了slf4j+logback的形式 ，slf4j是个通用的日志门面，logback就是个具体的日志框架了，我们记录日志的时候采用slf4j的方法去记录日志，底层的实现就是根据引用的不同日志jar去判定了。所以Spring Boot也能自动适配JCL、JUL、Log4J等日志框架，它的内部逻辑就是通过特定的JAR包去适配各个不同的日志框架。 从上图可以看出，Spring Boot通过jul-to-slf4j.jar去适配了JUL日志框架，通过log4j-to-slf4j.jar去适配了log4j日志框架。我们得知道，Spring5.x相对于Spring4.x有个不同的地方就是对底层使用的日志框架有了个大的改变，去除了原来默认使用的JCL 框架，而是采用SLF4j这个通用的日志门面，所以Spring Boot2.x相对于Spring Boot1.x来说去除了对JCL的适配。 SpringBoot能自动适配所有的日志，其底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要 把这个框架依赖的日志框架排除掉即可，因为Spring Boot会通过自己的jar去替代； 二、Logback的使用 SpringBoot底层默认使用slf4j+logback的方式进行日志记录 ，这里简单介绍一下logback的使用。 logbac日志级别从低到高分别为TRACE, DEBUG, INFO, WARN, ERROR 我们一般是在类路径下建立一个logback.xml,也可命名为(logback-spring.xml , logback-spring.groovy , logback.xml ，logback.groovy) 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; &lt;contextName&gt;spring-boot-logging&lt;/contextName&gt; &lt;property name=&quot;log.path&quot; value=&quot;log&quot; /&gt; &lt;!--输出到控制台--&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 级别过滤 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;log.path&#125;/spring-boot-logging.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/spring-boot-logging.%d&#123;yyyy-MM-dd&#125;.log.zip&lt;/fileNamePattern&gt; &lt;!-- 日志保存周期 --&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!-- 总大小 --&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;appender-ref ref=&quot;file&quot; /&gt; &lt;/root&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name=&quot;com.baiding&quot;/&gt;&lt;/configuration&gt; 1.根节点包含的属性1&lt;configuration&gt;&lt;/configuration&gt; scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟 debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false 2. 设置上下文名称1&lt;contextName&gt;spring-boot-logging&lt;/contextName&gt; 每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改,可以通过%contextName来打印日志上下文名称。 3.设置变量用来定义变量值的标签， 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量 1&lt;property name=&quot;log.path&quot; value=&quot;log&quot; /&gt; 4.子节点appenderappender用来格式化日志输出节点，有俩个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。 控制台输出ConsoleAppender 123456789101112&lt;!--输出到控制台--&gt;&lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 级别过滤 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt; filter是一个过滤器，表示对输出到控制台的日记进行过滤。有两种过滤器，分别为LevelFilter 和ThresholdFilter。执行一个过滤器会有返回个枚举值，即DENY，NEUTRAL，ACCEPT其中之一。返回DENY，日志将立即被抛弃不再经过其他过滤器；返回NEUTRAL，有序列表里的下个过滤器接着处理日志；返回ACCEPT，日志会被立即处理，不再经过剩余过滤器。 其中LevelFilter 为级别过滤器，根据日志级别进行过滤。其下有三个子节点，level表示过滤的级别，用于配置符合过滤条件的操作，ACCEPT符合级别的输出到控制台，用于配置不符合过滤条件的操作，DENY不符合的拒绝输出到控制台。 ThresholdFilter为临界值过滤器，过滤掉低于指定临界值的日志。当日志级别等于或高于临界值时，过滤器返回NEUTRAL；当日志级别低于临界值时，日志会被拒绝。 表示对日志进行格式化 %d{HH:mm:ss.SSS} ：日志的输出时间 %contextName ： 上下文名称 %thread : 输出日志的进程名字，这在Web应用以及异步任务处理中很有用 %-5level : 日志级别，并且使用5个字符靠左对齐 %logger{36} : 日志输出者的名字(一般为类名),名字最长36个字符，否则按照句点分割 %msg ： 具体的日志消息 %n ：换行符 输出到文件RollingFileAppender 1234567891011121314&lt;!--输出到文件--&gt; &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;log.path&#125;/spring-boot-logging.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/spring-boot-logging.%d&#123;yyyy-MM-dd&#125;.log.zip&lt;/fileNamePattern&gt; &lt;!-- 日志保存周期 --&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!-- 总大小 --&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; 常见的日志输出到文件，随着应用的运行时间越来越长，日志也会增长的越来越多，将他们输出到同一个文件并非一个好办法。RollingFileAppender用于切分文件日志。 其中file属性定义文件的带全路径的文件名，重要的是rollingPolicy的定义。 class=”ch.qos.logback.core.rolling.TimeBasedRollingPolicy”是最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责触发滚动 ${log.path}/spring-boot-logging.%d{yyyy-MMdd}.log.zip定义了日志的切分方式——把每一天的日志归档到一个文件中，同理，可以使用%d{yyyy-MM-dd HH-mm}来定义精确到分的日志切分方式。 30表示只保留最近30天的日志 1GB用来指定日志文件的上限大小，例如设置为1GB的话，那么到了这个值，就会删除旧的日志 子节点root1234&lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;appender-ref ref=&quot;file&quot; /&gt;&lt;/root&gt; root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性,默认是DEBUG。 其中可以包含零个或多个元素，表示我们定义的appender将会添加到我们定义的loger子节点中。 子节点loger 用来设置某一个包或者具体的某一个类的日志打印级别、以及指定 仅有一个name属性，一个可选的level和一个可选的addtivity属性 name:用来指定受此loger约束的某一个包或者具体的某一个类。 level:用来设置打印级别，如果未设置此属性，那么当前loger将会继承上级的级别。 addtivity:是否向上级loger传递打印信息。默认是true。 的实际使用有两种情况 第一种是不指定level,不指定appender 12345&lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;appender-ref ref=&quot;file&quot; /&gt;&lt;/root&gt;&lt;logger name=&quot;com.baiding.logging.SpringBootLoggingApplicationTests&quot;/&gt; 这时候的处理流程是：当SpringBootLoggingApplicationTests执行日志方法时，首先交给 处理(继承上级的level–info),将级别大于等于info的日志交给root,本身没有打印任何日志 第二种是指定了level,指定了appender 12345678&lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;appender-ref ref=&quot;file&quot; /&gt;&lt;/root&gt;&lt;!-- java中的包 --&gt;&lt;logger name=&quot;com.baiding&quot; level=&quot;warn&quot; addtivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;console&quot; /&gt;&lt;/logger&gt; 此logger指定了level为warn，addtivity为false，不在向上级传递打印信息，若设置了属性，但没有设置addtivity为false,则com.baiding包下的日志会先在名为console的appender记录一次，之后传递给上级，root又会在名为console和file的appender记录一次，这样就打印了两次了。 Spring Boot在使用logback记录日志时，推荐使用logback-spring.xml的格式，这样的话，日志框架就不直接加载日志的配置项，而是由SpringBoot解析日志配置，就可以使用SpringBoot 的高级Profile功能 如下logback-spring.xml 1234567&lt;springProfile name=&quot;dev&quot;&gt; &lt;logger name=&quot;com.baiding&quot; level=&quot;info&quot;/&gt;&lt;/springProfile&gt;&lt;springProfile name=&quot;prod&quot;&gt; &lt;logger name=&quot;com.baiding&quot; level=&quot;warn&quot;/&gt;&lt;/springProfile&gt; 可以在不同的节点中使用springProfile功能，用于指定某段配置只在某个环境下生效 。当然使用前，要激活profile。 三、切换Log4j2框架Spring Boot虽然默认使用Logback日志框架，但其内部也集成了Log4j2框架。要知道的是，在Java中，Log4j2框架的性能是最强的，所以我们一般在程序中使用Log4j2框架。下面介绍一下Log4j2的使用及其内部属性的含义。 首先，要在Spring Boot使用Log4j2的话，那么第一件事就是去除Logback的jar包，并引入Log4j2的jar。 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 上面就是在依赖Web模块的时候去除引用spring-boot-starter-logging.jar，之后依赖spring-boot-starter-log4j2.jar包。 之后在类路径下新建一个log4j2.xml,其具体内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt; &lt;Properties&gt; &lt;Property name=&quot;log.path&quot;&gt;log&lt;/Property&gt; &lt;/Properties&gt; &lt;!--先定义所有的appender--&gt; &lt;appenders&gt; &lt;!--这个输出控制台的配置--&gt; &lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt; &lt;/console&gt; &lt;File name=&quot;log&quot; fileName=&quot;$&#123;log.path&#125;/test.log&quot; append=&quot;false&quot;&gt; &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt; &lt;/File&gt; &lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;$&#123;log.path&#125;/info.log&quot; filePattern=&quot;$&#123;log.path&#125;/logs/$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;.log.zip&quot;&gt; &lt;!--只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy modulate=&quot;true&quot; interval=&quot;1&quot;/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!--然后定义logger，只有定义了logger并引入appender，appender才会生效--&gt; &lt;loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt; &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;/&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;/&gt; &lt;logger name=&quot;com.baiding&quot; level=&quot;INFO&quot;/&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 根节点属性 根节点Configuration有两个属性，status和monitorinterval status : status用来指定log4j2本身的日志的级别 monitorinterval : monitorinterval用于指定log4j自动重新配置的监测间隔时间，单位是s,最小是5s 2. Properties 标签在xml文件中，可以使用Properties 标签来自定义变量，方便其他地方的引用。 123&lt;Properties&gt; &lt;Property name=&quot;log.path&quot;&gt;log&lt;/Property&gt;&lt;/Properties&gt; 这里的log.path是定义日志存放的地方，此处是存放于项目根路径下的log文件夹中 3.Appenders 节点和logback一样，Appender是用来定义日志输出点的，一般常用有三个子节点，分别为Console、RollingFile、File。下面介绍一下各个子节点的用处及常用的属性 Console节点用来定义输出到控制台的Appender： name : 指定Appender的名字，用于Logger节点引用 target : SYSTEM_OUT 或 SYSTEM_ERR,一般设置为:SYSTEM_OUT PatternLayout : 指定日志输出格式，默认为%m%n 1234&lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;&lt;/console&gt; File节点用来定义输出到指定位置的文件的Appender: name : 指定Appender的名字，用于Logger节点引用 fileName : 指定输出日志的目的文件带全路径的文件名 append : 是否追加，默认为ture。ture是将新日志追加到原日志文件尾部，false则是删除已有文件，重建新文件 PatternLayout : 指定日志输出格式，默认为%m%n 123&lt;File name=&quot;log&quot; fileName=&quot;log/test.log&quot; append=&quot;false&quot;&gt; &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;&lt;/File&gt; RollingFile节点用来定义输出到指定位置的文件的Appender,但其记录的内容可拆分: File对文件的约束很简单，而RollingFile则比较灵活，其可根据文件大小来分拆，还可以根据时间来分拆 name : 指定Appender的名字，用于Logger节点引用 fileName : 指定输出日志的目的文件带全路径的文件名 filePattern:指定拆分出去的日志文件的全路径的文件名以及格式 PatternLayout : 指定日志输出格式，默认为%m%n Policies : 指定滚动日志的策略，就是什么时候进行新建日志文件输出日志. TimeBasedTriggeringPolicy : 基于时间进行日志的滚动 SizeBasedTriggeringPolicy : 基于文件大小进行日志的滚动 ThresholdFilter : 日志过滤器 12345678910111213&lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;$&#123;log.path&#125;/info.log&quot; filePattern=&quot;$&#123;log.path&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log.zip&quot;&gt; &lt;!--只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy modulate=&quot;true&quot; interval=&quot;1&quot;/&gt; &lt;/Policies&gt;&lt;/RollingFile&gt; 这里说一下TimeBasedTriggeringPolicy这个滚动策略的属性interval，它是指日志进行滚动的间隔，那么它的单位具体是什么呢？关键点在于filePattern的日志文件名所含有的日期格式%d{yyyy-MM-dd},这里日期格式具体到了天，那么以天为单位，若是日期具体到%d{yyyy-MM-dd-HH-mm}分钟的话，那么就是以分钟为单位。 这里还提到了日志过滤器，Log4j提供了许多的日志过滤器，具体可以看下文档 Filters。但我们一般采用ThresholdFilter,这个过滤器一般用来过滤掉所有级别低于它定义的级别的日志。 4.Loggers节点Loggers节点下一般有root和logger节点. root节点用来指定项目的根日志，如果没有单独指定logger，那么就会默认使用该root日志输出。 level ：日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF.appender-ref ：root的子节点，用来指定该日志输出到哪个Appender 1234&lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt;&lt;/root&gt; Logger节点用来单独指定日志的形式，比如要为某个包下所有的class或者某个具体的class指定不同的日志级别等。 level : 日志输出级别name : 用来指定该Logger所适用的类或者包.AppenderRef ：Logger的子节点，用来指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Rootadditivity ：是否向上级传递日志 true(默认)或false 1234&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;&lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;/&gt;&lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;/&gt;&lt;logger name=&quot;com.baiding&quot; level=&quot;INFO&quot;/&gt; 若我们为logger指定了AppenderRef ，别忘了将logger的additivity 属性设置为false,要不然日志可能会在指定的Appender中输出两遍 四、Log4j2异步输出日志Log4j2有个突出的功能就是支持高效低延迟的异步化写日志。日志异步输出的好处在于，使用单独的进程来执行日志打印的功能，可以提高日志执行效率，减少日志功能对正常业务的影响。 日志的异步输出使用了disruptor这个开源的并发框架，所以首先得导入disruptor.jar包 12345&lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt; 异步输出分为两种情况，一种为全异步模式，一种为异步和非异步混合输出模式。通过官方的性能对比，一般线程数在2-16之间的话，混合使用同步和异步的logger来打印日志，性能是最好的。 异步和非异步混合模式 这种模式的启用，主要在于两个节点的使用，分别为AsyncRoot和AsyncLogger,这两个节点可以和Root 或 Logger节点混合使用。 在这里修改一下上述的log4j2.xml文件中Loggers节点就可以了。 123456789&lt;loggers&gt; &lt;AsyncRoot level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt; &lt;/AsyncRoot&gt; &lt;AsyncLogger name=&quot;com.baiding&quot; level=&quot;INFO&quot; /&gt; &lt;AsyncLogger name=&quot;org.mybatis&quot; level=&quot;INFO&quot; /&gt; &lt;AsyncLogger name=&quot;org.springframework&quot; level=&quot;INFO&quot; /&gt;&lt;/loggers&gt;","path":"2019/08/25/SpringBoot鍏ラ棬绯诲垪锛氱鍥涚瘒 鏃ュ織璇﹁В/","date":"08-25","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"https://z.zhsh666.xyz/tags/java/"},{"name":"Java","slug":"Java","permalink":"https://z.zhsh666.xyz/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://z.zhsh666.xyz/tags/SpringBoot/"}]},{"title":"测试文章","text":"","path":"2019/08/25/测试文章/","date":"08-25","excerpt":"","tags":[{"name":"测试","slug":"测试","permalink":"https://z.zhsh666.xyz/tags/测试/"}]},{"title":"SpringBoot (一) ：入门篇","text":"什么是spring bootSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是spring boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。 使用spring boot有什么好处其实就是简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？ 1）配置web.xml，加载spring和spring mvc 2）配置数据库连接、配置spring事务 3）配置加载配置文件的读取，开启注解 4）配置日志文件 … 配置完成之后部署tomcat 调试 … 现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍! 但是如果使用spring boot呢？ 很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套web项目或者是构建一个微服务！ 快速入门 说了那么多，手痒痒的很，马上来一发试试! maven构建项目 1、访问http://start.spring.io/ 2、选择构建工具Maven Project、Spring Boot版本1.3.6以及一些工程基本信息，点击“Switch to the full version.”java版本选择1.7，可参考下图所示： 3、点击Generate Project下载项目压缩包 4、解压后，使用eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹-&gt; Finsh，OK done! 项目结构介绍 如上图所示，Spring Boot的基础结构共三个文件: src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序 另外，spingboot建议的目录结果如下： root package结构：com.example.myproject com +- example ​ +- myproject ​ +- Application.java ​ | ​ +- domain ​ | +- Customer.java ​ | +- CustomerRepository.java ​ | ​ +- service ​ | +- CustomerService.java ​ | ​ +- controller ​ | +- CustomerController.java ​ | Application.java 建议放到根目录下面,主要用于做一些框架配置 domain目录主要用于实体（Entity）与数据访问层（Repository） service 层主要是业务类代码 controller 负责页面访问控制 采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改 最后，启动Application main方法，至此一个java项目搭建好了！ 引入web模块 1、pom.xml中添加支持web的模块： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; pom.xml文件中默认有两个模块： spring-boot-starter ：核心模块，包括自动配置支持、日志和YAML； spring-boot-starter-test ：测试模块，包括JUnit、Hamcrest、Mockito。 2、编写controller内容： 1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping(&quot;/hello&quot;) public String index() &#123; return &quot;Hello World&quot;; &#125;&#125; @RestController 的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！ 3、启动主程序，打开浏览器访问http://localhost:8080/hello，就可以看到效果了，有木有很简单！ 如何做单元测试 打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。 1234567891011121314151617@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = MockServletContext.class)@WebAppConfigurationpublic class HelloWorldControlerTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); &#125;&#125; 开发环境的调试 热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目启重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置： 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。 总结 使用spring boot可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用sping boot非常适合构建微服务。","path":"2019/08/24/SpringBoot (涓€) 锛氬叆闂ㄧ瘒/","date":"08-24","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"https://z.zhsh666.xyz/tags/java/"},{"name":"Java","slug":"Java","permalink":"https://z.zhsh666.xyz/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://z.zhsh666.xyz/tags/SpringBoot/"}]}]}